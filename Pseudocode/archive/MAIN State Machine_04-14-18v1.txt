Note: Make sure for any serials, use a #define serial_type. So it can be replaced with PC USB's serial if needed.
Note: For redirects, it assumes only one arduino will be redirected to another. If by chance, two source Arduinos are being redirected to the same destination Arduino, only one will get through and the other message will be dropped.
	The prioritization will be giving to the hard coded order of the if/else statements.
	This is a design weakness that may be able to be improved later.
	For now keep it this way to reduce the complexity of the code and memory usage.
	So right now each transmission cycle will send up to two messages. One for internal messages going out, and the other for external messages being redirected to another external destination.
NOTE: MAIN will spend a lot of time redirecting data since AUXI and NAVI and COMM all need to go thru MAIN for data transfer


#define MAIN_SYSTEM_ERROR_TIMEOUT_VALUE ??//time for MAIN to wait in SYSTEM_ERROR before it should reset a hw reset from COMM
#define MAIN_SYNC_TIMEOUT_VALUE ??
#define SW_RESET_RESEND_TIMEOUT_VALUE		??//time to wait for AUXI's or NAVI's SW Reset Acknowledgement to MAIN before restarting the SW Reset, by sending a NAVI or AUXI SW Request again.
#define SW_RESET_ERROR_TIMEOUT_VALUE ??//time to waiting and resend the AUXI's or NAVI's SW Reset (Re-)Requests from MAIN before MAIN should just error out itself. Note: SW_RESET_ERROR_TIMEOUT_VALUE should be a greater value than SW_RESET_RESEND_TIMEOUT_VALUE
#define SLEEPING_ERROR_TIMEOUT_VALUE ??//time to waiting and keep resending the AUXI's or NAVI's Sleep Requests from MAIN (since unlike SW requests, if it's already asleep and you send it another request, there is no hard) before MAIN should just error out itself.
#define CONCURRENT_TRANSMISSION_DELAY		??//delay for about 1-5ms or so between potentially sending messages out again to the same arduino



At POR (defaults):
	Current State: RUN_HOUSEKEEPING_TASKS
	Next State: RUN_HOUSEKEEPING_TASKS
	Current Mode: POWER_ON_AND_HW_RESET *begin*
	Next Mode: POWER_ON_AND_HW_RESET 
	pc_usb_msg_queue = CMD_TAG_NO_MSG (command tag, not boolean since use by CREATE_DATA to generate messages as well as TX_COMMUNICATIONS as a flag)
	comm_msg_queue = CMD_TAG_NO_MSG (command tag, not boolean since use by CREATE_DATA to generate messages as well as TX_COMMUNICATIONS as a flag)
	navi_msg_queue = CMD_TAG_NO_MSG (command tag, not boolean since use by CREATE_DATA to generate messages as well as TX_COMMUNICATIONS as a flag)
	auxi_msg_queue = CMD_TAG_NO_MSG (command tag, not boolean since use by CREATE_DATA to generate messages as well as TX_COMMUNICATIONS as a flag)
	comm_cmnc_destination_selection = ROVERCOMM_COMM;//default to COMM
	redirectToPCUSB = false
	redirectToNAVI = false
	redirectToAUXI = false
	redirectToCOMM = false
	invalid_state_or_mode_error = false
	navi_system_ready = false	
	auxi_system_ready = false	
	navi_acknowledgement = false //a shared status flag, used for sw resets, sleep requests, etc. Make sure to clear it out before use and only use it for one purpose at a time. It's used with auxi_acknowledgement and run_task_on_main_now. See run_task_on_main_now for details.
	auxi_acknowledgement = false	//a shared status flag, used for sw resets, sleep requests, etc. Make sure to clear it out before use and only use it for one purpose at a time. It's used with navi_acknowledgement and run_task_on_main_now. See run_task_on_main_now for details.
	comm_system_ready = false	
	enable_mtr_pwr = false
	run_task_on_main_now = false //a shared status flag, used for sw resets, sleep requests, etc. Make sure to clear it out before use and only use it for one purpose at a time. It's used to track if auxi_acknowledgement and auxi_acknowledgement are true (i.e. they have given acknowledgements) before the system runs it's tasks for main.
	
	comm_cmnc_destination_selection = ROVERCOMM_COMM //default is COMM.
	
	//NAVI
	auto_MAIN_to_NAVI_data_array[] = {
		MTR_PWR_STATUS,
		ENC_STATUS_MID_LEFT,
		ENC_STATUS_MID_RIGHT
	}// add more as needed	
	auto_MAIN_to_NAVI_data_cnt = 0 //data counter
	
	//AUXI
	auto_MAIN_to_AUXI_data_array[] = {
		CMD_TAG_MTR_PWR_STATUS
		}// add more as needed
	auto_MAIN_to_AUXI_data_cnt = 0 //data counter
	
	
	//Note: Remember COMM currently only receives and processes generic system error and generic health errors. Also it can't redirect in some modes (i.e. SYNCHRONIZATION) so sending it an error (i.e. sync error) won't do any good.
	
	//COMM
	auto_MAIN_to_COMM_data_array[] = {
	}// add more as needed
	auto_MAIN_to_COMM_data_cnt = 0 //data counter
	
	//CMNC
	auto_MAIN_to_CMNC_data_array[] = {
		MTR_PWR_STATUS,
		ENC_STATUS_MID_LEFT,
		ENC_STATUS_MID_RIGHT
	}// add more as needed
	auto_MAIN_to_CMNC_data_cnt = 0 //data counter
	
	
	
	
	
	
	
	timeout_counter = 0 //shared counter, used to track how long MAIN has been waiting in the SYSTEM_ERROR state before requesting a hw reset from COMM, etc. Make sure to clear it out before use and only use it for one purpose at a time.
		Note: It could go to sw reset after waiting in the SYSTEM_ERROR state for a long time, but go ahead and go with a hw reset as that's known to work more reliability than the sw reset
	motor_power_prev_state = false //used to save the last state the motor power was on before turning it off to go to sleep
	error_origin = ROVERCOMM_NONE
	sw_reset_error = false
	sync_error = false
	sleeping_error = false
	generic_health_error = false
	generic_system_error = false
	transmission_delay_cnt = 0;//concurrent transmission delay counter
	first_transmission = true
							
MAIN:
		Loop
			RUN_HOUSEKEEPING_TASKS		
				POWER_ON_AND_HW_RESET
					run POR tasks
					Set mode to INITIALIZATION *begin*
					Go to whatever the next state is
						(still is Next State: RUN_HOUSEKEEPING_TASKS)							
				INITIALIZATION
					run initialization tasks
						initialize/reinitialize all variables
					start background tasks
					Set mode to SYNCHRONIZATION *begin*
					//initialize/reset shared counter before use
					timeout_counter = 0;
					Set next state to RX_COMMUNICATIONS
					Go to whatever the next state is
						(now just set to RX_COMMUNICATIONS)				
				SYNCHRONIZATION
					run background tasks
					Go to whatever the next state is				
				NORMAL_OPERATIONS		
					run background tasks
					Go to whatever the next state is				
				HW_RESETTING
					run background tasks
					Go to whatever the next state is					
				SYSTEM_SLEEPING
					run background tasks
					Go to whatever the next state is		
				SYSTEM_WAKING
					run background tasks
					Go to whatever the next state is						
				SW_RESETTING
					run background tasks
					Go to whatever the next state is			
				SYSTEM_ERROR
					run background tasks
					Go to whatever the next state is		
			RX_COMMUNICATIONS
				POWER_ON_AND_HW_RESET
					do nothing
				INITIALIZATION
					do nothing
				SYNCHRONIZATION					
					rxData() from PC_USB
					rxData() from COMM
					rxData() from AUXI
					rxData() from NAVI					
					Mode: SYNCHRONIZATION
					set next state to DATA_VALIDATION
					go to RUN_HOUSEKEEPING_TASKS							
				NORMAL_OPERATIONS	
					rxData() from PC_USB				
					rxData() from COMM
					rxData() from AUXI
					rxData() from NAVI					
					Mode: NORMAL_OPERATIONS
					set next state to DATA_VALIDATION
					go to RUN_HOUSEKEEPING_TASKS					
				HW_RESETTING
					do nothing				
				SYSTEM_SLEEPING
					rxData() from PC_USB
					rxData() from COMM
					rxData() from AUXI
					rxData() from NAVI					
					Mode: SYSTEM_SLEEPING
					set next state to DATA_VALIDATION
					go to RUN_HOUSEKEEPING_TASKS				
				SYSTEM_WAKING
					do nothing
				SW_RESETTING
					rxData() from PC_USB
					rxData() from COMM
					rxData() from AUXI
					rxData() from NAVI					
					Mode: SW_RESETTING
					set next state to DATA_VALIDATION
					go to RUN_HOUSEKEEPING_TASKS								
				SYSTEM_ERROR
					rxData() from PC_USB
					rxData() from COMM
					rxData() from AUXI
					rxData() from NAVI		
					Mode: SYSTEM_ERROR
					set next state to DATA_VALIDATION
					go to RUN_HOUSEKEEPING_TASKS						
			DATA_VALIDATION		
				POWER_ON_AND_HW_RESET
					do nothing
				INITIALIZATION
					do nothing
				SYNCHRONIZATION		
					parseAndValidateData() from PC_USB
					parseAndValidateData() from COMM
					parseAndValidateData() from AUXI
					parseAndValidateData() from NAVI
					Mode: SYNCHRONIZATION
					set next state to DATA_FILTER
					go to RUN_HOUSEKEEPING_TASKS
				NORMAL_OPERATIONS	
					parseAndValidateData() from PC_USB				
					parseAndValidateData() from COMM
					parseAndValidateData() from AUXI
					parseAndValidateData() from NAVI
					Mode: NORMAL_OPERATIONS
					set next state to DATA_FILTER
					go to RUN_HOUSEKEEPING_TASKS
				HW_RESETTING
					do nothing					
				SYSTEM_SLEEPING
					parseAndValidateData() from PC_USB
					parseAndValidateData() from COMM
					parseAndValidateData() from AUXI
					parseAndValidateData() from NAVI
					Mode: SYSTEM_SLEEPING
					set next state to DATA_FILTER
					go to RUN_HOUSEKEEPING_TASKS			
				SYSTEM_WAKING
					do nothing							
				SW_RESETTING
					parseAndValidateData() from PC_USB
					parseAndValidateData() from COMM
					parseAndValidateData() from AUXI
					parseAndValidateData() from NAVI
					Mode: SW_RESETTING
					set next state to DATA_FILTER
					go to RUN_HOUSEKEEPING_TASKS								
				SYSTEM_ERROR
					parseAndValidateData() from PC_USB
					parseAndValidateData() from COMM
					parseAndValidateData() from AUXI
					parseAndValidateData() from NAVI
					Mode: SYSTEM_ERROR
					set next state to DATA_FILTER
					go to RUN_HOUSEKEEPING_TASKS								
			DATA_FILTER
				POWER_ON_AND_HW_RESET
					do nothing
				INITIALIZATION
					do nothing
				SYNCHRONIZATION
					Allow all data from PC_USB (it's a debugging communication/backdoor to run tests, but use with caution)
						no redirections during SYNCHRONIZATION
					filter and throw away all COMM data except:
						no redirections during SYNCHRONIZATION
						generic system error message(s) from COMM/CMNC
						system ready message(s) from COMM	
						All SW Reset Request from COMM/CMNC (to restart the SW reset process again)				
						comm hw reset request message(s), from COMM (used to hw reset the COMM after the COMM has hw reset MAIN, NAVI, and AUXI)						
					filter and throw away all NAVI data except:
						no redirections during SYNCHRONIZATION
						generic system error message(s) from COMM/CMNC
						system ready message(s) from NAVI
					filter and throw away all AUXI data except:
						no redirections during SYNCHRONIZATION
						generic system error message(s) from AUXI
						generic health errors from AUXI
						system ready message(s) from AUXI					
					Unless overridden
						Mode: SYNCHRONIZATION
					set next state to READ_INPUTS //to read motor power status
					go to RUN_HOUSEKEEPING_TASKS					
				NORMAL_OPERATIONS		
					Allow all data from PC_USB (it's a debugging communication/backdoor to run tests, but use with caution)
					filter and direct PC_USB data
						if redirection needed NAVI:						
							redirectToNAVI = true
						if redirection needed AUXI:						
							redirectToAUXI = true
						else if redirection needed COMM:
							redirectToCOMM = true
						end if						
					filter and direct NAVI data
						if redirection needed AUXI:						
							redirectToAUXI = true
						else if redirection needed COMM:
							redirectToCOMM = true
						else if redirection needed PC_USB:
							redirectToPCUSB = true
						end if
					filter and direct AUXI data
						if redirection needed NAVI:						
							redirectToNAVI = true
						else if redirection needed COMM:
							redirectToCOMM = true
						else if redirection needed PC_USB:
							redirectToPCUSB = true							
						end if						
					filter and direct COMM data
						if redirection needed AUXI:						
							redirectToAUXI = true
						else if redirection needed NAVI:
							redirectToNAVI = true
						else if redirection needed PC_USB:
							redirectToPCUSB = true							
						end if							
					Mode: NORMAL_OPERATIONS
					set next state to READ_INPUTS
					go to RUN_HOUSEKEEPING_TASKS			
				HW_RESETTING
					do nothing				
				SYSTEM_SLEEPING		
					
					no redirections during SYSTEM_SLEEPING				
					
					Allow all data from PC_USB (it's a debugging communication/backdoor to run tests, but use with caution)
						no redirections during SYNCHRONIZATION
					filter and throw away all COMM data except:						
						All SW Reset Requests from COMM/CMNC			
						generic system error message(s) from COMM/CMNC
						All Sleep (Re-)Request from COMM/CMNC (to restart the sleep process again)
							Note: Allow sleep (Re-)Request to override the sleep process if needed
							Note: No need to worry about allowing HW requests to override when in SYSTEM_SLEEPING with MAIN.
								Since when there is a HW reset, it will first start by the COMM resetting MAIN, which will take MAIN out of the SYSTEM_SLEEPING mode anyways.
								After POR, MAIN will be able to HW reset COMM when MAIN is in the SYNCHRONIZATION mode.					
							TROUBLESHOOTING TIP: Make sure it doesn't keep getting stuck in the sleep request state.
							Note: There is no Sleeping Request Acknowledgement from COMM, since it is the one that starts off the sleeping process then puts itself to sleep.
					filter and throw away all NAVI data except:
						Sleeping Request Acknowledgement from NAVI	
						generic system error message(s) from NAVI
					filter and throw away all AUXI data except:
						Sleeping Request Acknowledgement from AUXI
						generic system error message(s) from AUXI
						generic health errors from AUXI
					Mode: SYSTEM_SLEEPING
					set next state to READ_INPUTS //to read motor power status
					go to RUN_HOUSEKEEPING_TASKS						
				SYSTEM_WAKING
					do nothing		
				SW_RESETTING	
					Allow all data from PC_USB (it's a debugging communication/backdoor to run tests, but use with caution)
						no redirections during SW_RESETTING
					filter and throw away all COMM data except:
						generic system error message(s) from COMM/CMNC
						All SW Reset (Re-)Request from COMM/CMNC (to restart the SW reset process again)
							Note: Allow All SW Reset (Re-)Request to override the sw reset process if needed
							Note: No need to worry about allowing HW requests to override when in SW_RESETTING with MAIN.
									Since when there is a HW reset, it will first start by the COMM resetting MAIN, which will take MAIN out of the SW_RESETTING mode anyways.
									After POR, MAIN will be able to HW reset COMM when MAIN is in the SYNCHRONIZATION mode.					
							TROUBLESHOOTING TIP: Make sure it doesn't keep getting stuck in the re-resetting state.
					filter and throw away all NAVI data except:
						SW Reset Acknowledgement from NAVI
						generic system error message(s) from NAVI
					filter and throw away all AUXI data except:
						SW Reset Acknowledgement from AUXI						
						generic system error message(s) from AUXI
						generic health errors from AUXI
					Mode: SW_RESETTING
					set next state to READ_INPUTS
					go to RUN_HOUSEKEEPING_TASKS						
				SYSTEM_ERROR
					Allow all data from PC_USB (it's a debugging communication/backdoor to run tests, but use with caution)
						filter and direct PC_USB data
							if redirection needed NAVI:						
								redirectToNAVI = true
							if redirection needed AUXI:						
								redirectToAUXI = true
							else if redirection needed COMM:
								redirectToCOMM = true
							end if	
					filter and throw away all COMM data except:
						generic system error message(s) from COMM/CMNC
						all sw reset request message(s) from COMM
						mid left encoder requests (used for debugging)
						mid right encoder requests (used for debugging)
						motor power status requests (used for debugging)
						any redirections
							if redirection needed to AUXI:						
							redirectToAUXI = true						
							else if redirection needed to NAVI:						
								redirectToNAVI = true							
							else if redirection needed PC_USB:
								redirectToPCUSB = true								
							end if
						Allow all COMM/CMNC data to be redirected so AUXI/NAVI can send requested data back. Each Arduino will filter out what it will allow in error mode.						
						Note: There is no need for HW requests here, since when there is a HW reset, it will first start by the COMM resetting MAIN, which will take MAIN out of the SYSTEM_ERROR mode anyways.
									After POR, MAIN will be able to HW reset COMM when MAIN is in the SYNCHRONIZATION mode.						
					filter and throw away all NAVI data except:
						//Note: All SW and HW requests should be initiated originally from COMM (and not NAVI or AUXI)
						any redirections
						generic system error message(s) from NAVI
						mid left encoder requests (used for debugging)
						mid right encoder requests (used for debugging)
						motor power status requests (used for debugging)
						if redirection needed to AUXI:						
							redirectToAUXI = true
						else if redirection needed COMM or CMNC:
							redirectToCOMM = true
						else if redirection needed PC_USB:
							redirectToPCUSB = true							
						end if
						(to allow system data to be passed/redirected from NAVI to MAIN, AUXI or COMM or CMNC)
					filter and throw away all AUXI data except:
						//Note: All SW and HW requests should be initiated originally from COMM (and not NAVI or AUXI)
						mid left encoder requests (used for debugging)
						mid right encoder requests (used for debugging)
						motor power status requests (used for debugging)
						generic system error message(s) from AUXI
						generic health errors from AUXI
						any redirections
						if redirection needed to NAVI:						
							redirectToNAVI = true
						else if redirection needed COMM or CMNC:
							redirectToCOMM = true
						else if redirection needed PC_USB:
							redirectToPCUSB = true							
						end if
						(to allow system data to be passed/redirected from AUXI to MAIN, NAVI or COMM or CMNC)

					Mode: SYSTEM_ERROR
					set next state to READ_INPUTS
					go to RUN_HOUSEKEEPING_TASKS			
			READ_INPUTS
				POWER_ON_AND_HW_RESET
					do nothing
				INITIALIZATION
					do nothing
				SYNCHRONIZATION
					skip encoders
					read motor power status
					Mode: SYNCHRONIZATION
					set next state to PROCESS_DATA
					go to RUN_HOUSEKEEPING_TASKS						
				NORMAL_OPERATIONS
					read encoders
					read motor power status
					Mode: NORMAL_OPERATIONS
					set next state to PROCESS_DATA
					go to RUN_HOUSEKEEPING_TASKS					
				HW_RESETTING
					do nothing				
				SYSTEM_SLEEPING
					skip encoders
					read motor power status
					Mode: SYSTEM_SLEEPING
					set next state to PROCESS_DATA
					go to RUN_HOUSEKEEPING_TASKS	
				SYSTEM_WAKING
					do nothing			
				SW_RESETTING
					skip encoders
					read motor power status
					Mode: SW_RESETTING
					set next state to PROCESS_DATA
					go to RUN_HOUSEKEEPING_TASKS				
				SYSTEM_ERROR
					read encoders
					read motor power status
					Mode: SYSTEM_ERROR
					set next state to PROCESS_DATA
					go to RUN_HOUSEKEEPING_TASKS	
			PROCESS_DATA
				POWER_ON_AND_HW_RESET
					do nothing
				INITIALIZATION
					do nothing	
				SYNCHRONIZATION
					
					skip encoder data
					process motor power status
					
					
					Categorize all commands/data from all sources.
					Allow for all non-conflicting commands to run.
					Sort based on priority.
					Then only run the highest priority for MAIN.												

					
					//Run lower priority functions here. (i.e. system ready msgs)
							

					//Set comm_cmnc_destination_selection as needed if the destination needs to be CMNC instead of the default COMM.
					
					Process PC_USB command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)
						No redirections in SYNCHRONIZATION.
						All other messages are allowed from PC_USB. Use with caution.						
						
					Process COMM command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)
						No redirections in SYNCHRONIZATION.
						Note: If system ready msg, hw reset request, generic system error, or All SW Reset Request from COMM/CMNC, see "Command Options" below for more info.
						Note: Either you should get HW or SW reset, generic system error, or system ready messages from COMM. as everything else was filtered out
										
					Process NAVI command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)
						No redirections in SYNCHRONIZATION.
						Note: If system ready msg, or generic system error received from NAVI, see "Command Options" below for more info.
						Note: Either you should get system ready messages, or generic system error from NAVI. as everything else was filtered out
						
					Process AUXI command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)
						No redirections in SYNCHRONIZATION.					
						Note: If system ready msg, generic system error, or generic health error received from AUXI, see "Command Options" below for more info.
						Note: Either you should get system ready messages, generic system error, or generic health error from AUXI. as everything else was filtered out
	
					


					//check each arduino to see which isn't ready yet and keep having it send out system ready status from MAIN
					if comm_system_ready == false
						comm_msg_queue = SYSTEM_READY_STATUS (tells COMM it's ready to synchronize)					
						comm_cmnc_destination_selection = ROVERCOMM_COMM;						
					end if
					if navi_msg_queue == false
						navi_msg_queue = SYSTEM_READY_STATUS (tells NAVI it's ready to synchronize)						
						comm_cmnc_destination_selection = ROVERCOMM_NAVI;						
					end if
					if auxi_msg_queue == false
						auxi_msg_queue = SYSTEM_READY_STATUS (tells AUXI it's ready to synchronize)						
						comm_cmnc_destination_selection = ROVERCOMM_AUXI;						
					end if



					
					
					//ignore any other commands. it should have been filter out anyways. (because only system ready msgs can pass the data filter)
										
					//Run highest priority functions here. //this will override any lower priority messages (see below)
										
					//Check to see if all systems are ready for systems go
					if navi_system_ready = true && auxi_system_ready = true && comm_system_ready = true //the status for a particular arduino (i.e. navi_system_ready fpr NAVI) would be set true when the system ready msg was received for that arduino
						comm_msg_queue = SYSTEM_GO_STATUS
						navi_msg_queue = SYSTEM_GO_STATUS
						auxi_msg_queue = SYSTEM_GO_STATUS	
						
						comm_cmnc_destination_selection = ROVERCOMM_COMM;						
						
						Mode: NORMAL_OPERATIONS *begin*						
					else		
						//increment counter
						timeout_counter++
						//if MAIN has been stuck in SYNCHRONIZATION for a long time while waiting on NAVI, AUXI, or COMM, it will send a sync error status
						if timeout_counter >= MAIN_SYNC_TIMEOUT_VALUE					
						Set mode to SYSTEM_ERROR *begin*
						set enable_mtr_pwr = false //shut down motor when in error for safety
						Set error_origin = ROVERCOMM_MAIN						
						pc_usb_msg_queue = SYNC_ERROR_STATUS //send error out through the PC_USB for debugging						
						comm_msg_queue = GENERIC_SYSTEM_ERROR//send COMM a generic system error for now since COMM doesn't handle other errors yet (besides generic health errors). And though you can try to send it to CMNC, sometimes redirection may be off in certain modes. So it's better for COMM to receive a generic error and do what it has to do (i.e. put the LED indicator to error pattern and send a generic system error to CMNC)
						 
						comm_cmnc_destination_selection = ROVERCOMM_COMM;
						set sync_error = true
							(Note: the sync_error flag can only be cleared with a sw reset or hw reset)			
						//initialize/reset shared counter before use
						timeout_counter = 0;
					end if
					
					
					process any hw reset request from MAIN to COMM for COMM to do a reset on COMM here //all the message queues will be the same. Just COMM will be HW reset while everything else is starting up or is ready already
					
						
					Unless overridden,
						set next state to CREATE_DATA
					Unless overridden,						
						Mode: SYNCHRONIZATION
					go to RUN_HOUSEKEEPING_TASKS
					
				NORMAL_OPERATIONS

					process encoder data
					process motor power status
					
					
					Categorize all commands/data from all sources.
					Allow for all non-conflicting commands to run.
					Sort based on priority.
					Then only run the highest priority for MAIN.												

					//Run lower priority functions here.
										
							
					//Set comm_cmnc_destination_selection as needed if the destination needs to be CMNC instead of the default COMM.
							
					Process PC_USB command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)
						All messages are allowed from PC_USB. Use with caution.
					Process COMM command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)						
						All messages are allowed from COMM.
					Process NAVI command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)						
						All messages are allowed from NAVI.
					Process AUXI command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)
						All messages are allowed from AUXI.
																

															
					//Run highest priority functions here. //this will override any lower priority messages
						

					Unless overridden,
						set next state to CONTROL_OUTPUTS					
					Unless overridden,						
						Mode: NORMAL_OPERATIONS
					go to RUN_HOUSEKEEPING_TASKS	
					
				HW_RESETTING
					do nothing				
				SYSTEM_SLEEPING
	
					skip encoder data
					process motor power status
					
					Categorize all commands/data from all sources.
					Allow for all non-conflicting commands to run.
					Sort based on priority.
					Then only run the highest priority for MAIN.	
					
					
																		
					//Run lower priority functions here.
					
					//Set comm_cmnc_destination_selection as needed if the destination needs to be CMNC instead of the default COMM.
					
					Process PC_USB command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)
						All other messages are allowed from PC_USB. Use with caution.
						
					Process COMM command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)						
						No redirections in SYSTEM_SLEEPING.
						Note: Either you should get no data, generic system error, All SW Reset Requests, or All Sleep (Re-)Request from COMM/CMNC. as everything else was filtered out					
						
					Process NAVI command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)						
						No redirections in SYSTEM_SLEEPING.
						Note: Either you should get no data, generic system error, or Sleeping Request Acknowledgement from NAVI. as everything else was filtered out
						
					Process AUXI command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)
						No redirections in SYSTEM_SLEEPING.
						Note: Either you should get no data, generic system error, generic health error, or Sleeping Request Acknowledgement from AUXI. as everything else was filtered out					
											
											


	
					
					if run_task_on_main_now = false//aka navi_acknowledgement == false or auxi_acknowledgement == false
						//One or more of the System Sleeping Acknowledgements have not been received yet
						//Note: If all acknowledgements were received, run_task_on_main_now would be true
						//Regenerate the messages as needed
						//check each arduino to see which hasn't sent a Sleeping Request Acknowledgement to MAIN yet.
						
						if navi_acknowledgement == false
							navi_msg_queue = NAVI_SLEEP_REQUEST (tells NAVI to go to sleep)
						end if
						
						if auxi_acknowledgement == false
							auxi_msg_queue = AUXI_SLEEP_REQUEST (tells AUXI to go to sleep)
						end if		
						
						//increment counter. Note: The counter may be incremented even though sleep acknowledgement was just received, but once it's processed below, it will override any errors if all the acknowledgements were received. So no worries increment the timeout counter and checking for timeout here.
						
						timeout_counter++
						
						//if MAIN has been stuck in SYSTEM_SLEEPING for a long time while waiting on NAVI and/or AUXI for sleep request acknowledgements
						if timeout_counter >= SLEEPING_ERROR_TIMEOUT_VALUE					
							Set mode to SYSTEM_ERROR *begin*
							Set error_origin = ROVERCOMM_MAIN
							set enable_mtr_pwr = false //shut down motor when in error for safety
							//Create the error message for the message queues for the first time
							pc_usb_msg_queue = SLEEP_ERROR_STATUS //send error out through the PC_USB for debugging
							comm_msg_queue = GENERIC_SYSTEM_ERROR//send COMM a generic system error for now since COMM doesn't handle other errors yet (besides generic health errors). And though you can try to send it to CMNC, sometimes redirection may be off in certain modes. So it's better for COMM to receive a generic error and do what it has to do (i.e. put the LED indicator to error pattern and send a generic system error to CMNC)
							comm_cmnc_destination_selection = ROVERCOMM_COMM;							
							set sleeping_error = true
							(Note: the sleeping_error flag can only be cleared with a sw reset or hw reset)					
							//initialize/reset shared counter before use
							timeout_counter = 0;
						end if			
					end if
					else//run_task_on_main_now = true and navi_acknowledgement and auxi_acknowledgement flags are true, all the System Sleeping Acknowledgements have been received
						//so clear the flags
						navi_acknowledgement = false
						auxi_acknowledgement = false			
						//Note: navi_acknowledgement and auxi_acknowledgement will be cleared before use, but do it here anyways just in case
						
								
						//If both acknowledgements are received, allow the Sleep Request Acknowledgement command to have the highest priority on the message queues, modes, and states (over error messages). It will override it since run_task_on_main_now = true and the else block of code here will run.
						
						comm_msg_queue = COMM_SLEEP_REQUEST //MAIN sends COMM a COMM Sleep request, so COMM can go to sleep
						
						comm_cmnc_destination_selection = ROVERCOMM_COMM;
						
						
						//initialize/reset shared counter for future use and to prevent being stuck in a loop
						timeout_counter = 0;
						
						
						//Note: run_task_on_main_now will be cleared later in TX_COMMUNICATIONS when it's done being used by that state
					end else



					//Run highest priority functions here. //this will override any lower priority messages (see below)
										
			
					//If both acknowledgements are received, allow the Sleep Request Acknowledgement command to have the highest priority on the message queues, modes, and states (over error messages)
			
			

					Unless overridden,
						set next state to CONTROL_OUTPUTS								
					Unless overridden,						
						Mode: SYSTEM_SLEEPING
					go to RUN_HOUSEKEEPING_TASKS	

				
				
				SYSTEM_WAKING
					do nothing			
				SW_RESETTING
		

					skip encoder data
					process motor power status
					
					
					Categorize all commands/data from all sources.
					Allow for all non-conflicting commands to run.
					Sort based on priority.
					Then only run the highest priority for MAIN.												

					
																					
					//Run lower priority functions here.


					//Set comm_cmnc_destination_selection as needed if the destination needs to be CMNC instead of the default COMM.
					
					
					Process PC_USB command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)
						No redirections in SW_RESETTING.
						All other messages are allowed from PC_USB. Use with caution.
						
					Process COMM command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)						
						Note: Either you should get no data, generic system error, or All SW Reset (Re-)Request from COMM/CMNC. as everything else was filtered out.							
						
					Process NAVI command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)						
						Note: Either you should get no data, generic system error, or SW Reset Acknowledgement from NAVI. as everything else was filtered out.
						
					Process AUXI command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)
						Note: Either you should get no data, generic system error, generic health error, or SW Reset Acknowledgement from AUXI. as everything else was filtered out.
																

					
					//Run highest priority functions here. //this will override any lower priority messages
						
			

					//For SW_RESETTING, it uses a dual timeout design
					Note: SW_RESET_ERROR_TIMEOUT_VALUE should be greater than SW_RESET_RESEND_TIMEOUT_VALUE
					
					
					if run_task_on_main_now = false//aka navi_acknowledgement == false or auxi_acknowledgement == false
						//One or more of the SW Reset Acknowledgements have not been received yet
						//Note: If all acknowledgements were received, run_task_on_main_now would be true
						//increment the loop count while waiting wait for AUXI or NAVI SW Reset Acknowledgement to MAIN
					
						//increment counter. Note: The counter may be incremented even though SW Reset Acknowledgement was just received, but once it's processed below, it will override any errors if all the acknowledgements were received. So no worries increment the timeout counter and checking for timeout here.
						timeout_counter++
						
						//if MAIN has been stuck in SW_RESETTING for a long time while waiting on NAVI and/or AUXI for SW Request acknowledgements
						if timeout_counter >= SW_RESET_ERROR_TIMEOUT_VALUE					
							Set mode to SYSTEM_ERROR *begin*
							Set error_origin = ROVERCOMM_MAIN
							set enable_mtr_pwr = false //shut down motor when in error for safety
							//Create the error message for the message queues for the first time
							pc_usb_msg_queue = SW_RESET_ERROR_STATUS //send error out through the PC_USB for debugging
							comm_msg_queue = GENERIC_SYSTEM_ERROR//send COMM a generic system error for now since COMM doesn't handle other errors yet (besides generic health errors). And though you can try to send it to CMNC, sometimes redirection may be off in certain modes. So it's better for COMM to receive a generic error and do what it has to do (i.e. put the LED indicator to error pattern and send a generic system error to CMNC)
							navi_msg_queue = SW_RESET_ERROR_STATUS //To let the Arduino know MAIN is in error and the motor will be shut off, etc.
							auxi_msg_queue = SW_RESET_ERROR_STATUS //To let the Arduino know MAIN is in error and the motor will be shut off, etc.							
							
							comm_cmnc_destination_selection = ROVERCOMM_COMM;
							
							
							sw_reset_error = true
								(Note: the sw_reset_error flag can only be cleared with a hw reset)
							//initialize/reset shared counter before use
							timeout_counter = 0;
						end if
						//else if it just waited a little bit, it should try resending the SW reset request to AUXI or NAVI from MAIN
						else if timeout_counter >= SW_RESET_RESEND_TIMEOUT_VALUE
							//Regenerate the messages as needed
							
							//Note: It should send the request periodically and not continuously so the system has time to process the request and it doesn't get stuck in a loop. it will get cleared out in TX_COMMUNICATIONS after the messages are sent.
							
							//check each arduino to see which hasn't sent a SW Reset Acknowledgement to MAIN yet.
							if navi_acknowledgement == false
								navi_msg_queue = NAVI_SW_RESET_REQUEST (tells NAVI to do a SW reset)
							end if
							if auxi_acknowledgement == false
								auxi_msg_queue = AUXI_SW_RESET_REQUEST (tells AUXI to do a SW reset)
							end if					
							//Don't reset timeout_counter, keep counting and see if it will reach the SW_RESET_ERROR_TIMEOUT_VALUE
						end if
					end if
					else//run_task_on_main_now = true aka navi_acknowledgement and auxi_acknowledgement flags are true, all the SW Reset Acknowledgements have been received
						//so clear the flags
						navi_acknowledgement = false
						auxi_acknowledgement = false
						//Note: navi_acknowledgement and auxi_acknowledgement will be cleared before use, but do it here anyways just in case
								
						//If both acknowledgements are received, allow the SW Reset Acknowledgement command to have the highest priority on the message queues, modes, and states (over error messages). It will override it since run_task_on_main_now = true and the else block of code here will run.
				
						comm_msg_queue = COMM_SW_RESET_REQUEST //MAIN sends COMM a COMM SW request, so COMM can do a SW reset
						
						comm_cmnc_destination_selection = ROVERCOMM_COMM;
						
						//initialize/reset shared counter for future use and to prevent being stuck in a loop
						timeout_counter = 0;			
				

						//Note: run_task_on_main_now will be cleared later in TX_COMMUNICATIONS when it's done being used by that state
					end else
					
					
										
						
					Unless overridden,
						set next state to CONTROL_OUTPUTS								
					Unless overridden,						
						Mode: SW_RESETTING
					go to RUN_HOUSEKEEPING_TASKS	

			SYSTEM_ERROR	
				
				
					process encoder data					
					process motor power status
					
					Categorize all commands/data from all sources.
					Allow for all non-conflicting commands to run.
					Sort based on priority.
					Then only run the highest priority for MAIN.

					
					//Run lower priority functions here. (i.e. error status)
	
	
					//Set comm_cmnc_destination_selection as needed if the destination needs to be CMNC instead of the default COMM.
					
					
					Process PC_USB command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)
						All messages are allowed from PC_USB. Use with caution.
					Process COMM command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)						
						Note: Either you should get All SW requests, motor power status, mid left or mid right encoder status requests, or generic system errors. as everything else was filtered out
					Process NAVI command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)						
						Note: Either you should get generic system errors, motor power status, mid left or mid right encoder status requests, or redirections from NAVI. as everything else was filtered out
					Process AUXI command/data to see if it has priority or is non-conflicting (see "Command Options" below for more info)
						Note: Either you should get generic system errors, motor power status, mid left or mid right encoder status requests, redirections and generic health errors from AUXI. as everything else was filtered out
								
				
					
					//Recreate/regenerate any error messages (but allow them to be overwritten by higher priority messages)
					Improvement Tip: Maybe can send NAVI and AUXI the error messages as well so they can react to it. But for now good enough.
					if sync_error
						(Note: the sync_error flag can only be cleared with a sw reset or hw reset)					
						
						pc_usb_msg_queue = SYNC_ERROR_STATUS //send error out through the PC_USB for debugging
										

						if( error_origin != ROVERCOMM_COMM)//Make sure don't send it back to itself to avoid an infinite loop
						{
							comm_msg_queue = GENERIC_SYSTEM_ERROR//send COMM a generic system error for now since COMM doesn't handle other errors yet (besides generic health errors). And though you can try to send it to CMNC, sometimes redirection may be off in certain modes. So it's better for COMM to receive a generic error and do what it has to do (i.e. put the LED indicator to error pattern and send a generic system error to CMNC)
							
							comm_cmnc_destination_selection = ROVERCOMM_COMM;
							
						}//end if						
						if( error_origin != ROVERCOMM_AUXI)//Make sure don't send it back to itself to avoid an infinite loop
						{
							auxi_msg_queue = CMD_TAG_GENERIC_SYSTEM_ERROR_STATUS;//also send a copy to AUXI so every Arduino will know of the error
						}//end if							
						if( error_origin != ROVERCOMM_NAVI)//Make sure don't send it back to itself to avoid an infinite loop
						{
							navi_msg_queue = CMD_TAG_GENERIC_SYSTEM_ERROR_STATUS;//also send a copy to NAVI so every Arduino will know of the error
						}//end if							
						
						(Note: the sync_error flag can only be cleared with a sw reset or hw reset)		
						
						
					else if sw_reset_error
					
						pc_usb_msg_queue = SW_RESET_ERROR_STATUS //send error out through the PC_USB for debugging
						
						if( error_origin != ROVERCOMM_COMM)//Make sure don't send it back to itself to avoid an infinite loop
						{
							comm_msg_queue = GENERIC_SYSTEM_ERROR//send COMM a generic system error for now since COMM doesn't handle other errors yet (besides generic health errors). And though you can try to send it to CMNC, sometimes redirection may be off in certain modes. So it's better for COMM to receive a generic error and do what it has to do (i.e. put the LED indicator to error pattern and send a generic system error to CMNC)
							
							comm_cmnc_destination_selection = ROVERCOMM_COMM;
							
						}//end if																			
						if( error_origin != ROVERCOMM_NAVI)//Make sure don't send it back to itself to avoid an infinite loop
						{
							navi_msg_queue = CMD_TAG_GENERIC_SYSTEM_ERROR_STATUS;//also send a copy to NAVI so every Arduino will know of the error
						}//end if	
						if( error_origin != ROVERCOMM_AUXI)//Make sure don't send it back to itself to avoid an infinite loop
						{
							auxi_msg_queue = CMD_TAG_GENERIC_SYSTEM_ERROR_STATUS;//also send a copy to AUXI so every Arduino will know of the error
						}//end if							
						
						
						(Note: the sw_reset_error flag can only be cleared with a hw reset)
						Troubleshooting tip, if it's a sw_reset_error, it will need a HW reset. But SYSTEM_ERROR will allow for both sw and hw resets because it's designed to handle any errors in general. So the user will have to know to send a HW reset in order to clear a SW reset error.
					else if sleeping_error
						
						pc_usb_msg_queue = SLEEP_ERROR_STATUS //send error out through the PC_USB for debugging

						if( error_origin != ROVERCOMM_COMM)//Make sure don't send it back to itself to avoid an infinite loop
						{
							comm_msg_queue = GENERIC_SYSTEM_ERROR//send COMM a generic system error for now since COMM doesn't handle other errors yet (besides generic health errors). And though you can try to send it to CMNC, sometimes redirection may be off in certain modes. So it's better for COMM to receive a generic error and do what it has to do (i.e. put the LED indicator to error pattern and send a generic system error to CMNC)
							
							comm_cmnc_destination_selection = ROVERCOMM_COMM;
							
						}//end if							
						if( error_origin != ROVERCOMM_NAVI)//Make sure don't send it back to itself to avoid an infinite loop
						{
							navi_msg_queue = CMD_TAG_GENERIC_SYSTEM_ERROR_STATUS;//also send a copy to NAVI so every Arduino will know of the error
						}//end if	
						if( error_origin != ROVERCOMM_AUXI)//Make sure don't send it back to itself to avoid an infinite loop
						{
							auxi_msg_queue = CMD_TAG_GENERIC_SYSTEM_ERROR_STATUS;//also send a copy to AUXI so every Arduino will know of the error
						}//end if		
												
						
						(Note: the sleeping_error flag can only be cleared with a sw reset or hw reset)				
					else if invalid_state_or_mode_error

						pc_usb_msg_queue = CMD_TAG_INVALID_STATE_OR_MODE_ERROR_STATUS
						
						if( error_origin != ROVERCOMM_COMM)//Make sure don't send it back to itself to avoid an infinite loop
						{
							comm_msg_queue = GENERIC_SYSTEM_ERROR//send COMM a generic system error for now since COMM doesn't handle other errors yet (besides generic health errors). And though you can try to send it to CMNC, sometimes redirection may be off in certain modes. So it's better for COMM to receive a generic error and do what it has to do (i.e. put the LED indicator to error pattern and send a generic system error to CMNC)

							comm_cmnc_destination_selection = ROVERCOMM_COMM;
							
						}//end if							
						if( error_origin != ROVERCOMM_NAVI)//Make sure don't send it back to itself to avoid an infinite loop
						{
							navi_msg_queue = CMD_TAG_GENERIC_SYSTEM_ERROR_STATUS;//also send a copy to NAVI so every Arduino will know of the error
						}//end if	
						if( error_origin != ROVERCOMM_AUXI)//Make sure don't send it back to itself to avoid an infinite loop
						{
							auxi_msg_queue = CMD_TAG_GENERIC_SYSTEM_ERROR_STATUS;//also send a copy to AUXI so every Arduino will know of the error
						}//end if			
						
						(Note: the invalid_state_or_mode_error flag can only be cleared with a sw reset or hw reset)
						
					else if generic_health_error
						pc_usb_msg_queue = CMD_TAG_GENERIC_HEALTH_STATUS_ERROR //send error out through the PC_USB for debugging

						if( error_origin != ROVERCOMM_COMM)//Make sure don't send it back to itself to avoid an infinite loop
						{
							comm_msg_queue = CMD_TAG_GENERIC_HEALTH_STATUS_ERROR;//send error to comm which will send a copy to cmnc as well
							
							comm_cmnc_destination_selection = ROVERCOMM_COMM;
							
						}//end if							
						if( error_origin != ROVERCOMM_NAVI)//Make sure don't send it back to itself to avoid an infinite loop
						{
							navi_msg_queue = CMD_TAG_GENERIC_HEALTH_STATUS_ERROR;//also send a copy to NAVI so every Arduino will know of the error
						}//end if	
						if( error_origin != ROVERCOMM_AUXI)//Make sure don't send it back to itself to avoid an infinite loop
						{
							auxi_msg_queue = CMD_TAG_GENERIC_HEALTH_STATUS_ERROR;//also send a copy to AUXI so every Arduino will know of the error
						}//end if		
												
						(Note: the generic_health_error flag can only be cleared with a sw reset or hw reset)				
					else if generic_system_error
					
						pc_usb_msg_queue = GENERIC_SYSTEM_ERROR //send error out through the PC_USB for debugging
						
						if( error_origin != ROVERCOMM_COMM)//Make sure don't send it back to itself to avoid an infinite loop
						{
							comm_msg_queue = GENERIC_SYSTEM_ERROR;//send error to comm which will send a copy to cmnc as well
							
							comm_cmnc_destination_selection = ROVERCOMM_COMM;
							
						}//end if							
						if( error_origin != ROVERCOMM_NAVI)//Make sure don't send it back to itself to avoid an infinite loop
						{
							navi_msg_queue = CMD_TAG_GENERIC_SYSTEM_ERROR_STATUS;//also send a copy to NAVI so every Arduino will know of the error
						}//end if	
						if( error_origin != ROVERCOMM_AUXI)//Make sure don't send it back to itself to avoid an infinite loop
						{
							auxi_msg_queue = CMD_TAG_GENERIC_SYSTEM_ERROR_STATUS;//also send a copy to AUXI so every Arduino will know of the error
						}//end if							
						
						(Note: the generic_system_error flag can only be cleared with a sw reset or hw reset)

					else//default: set to generic_system_error
						Set generic_system_error = true
						
						(Note: the generic_system_error flag can only be cleared with a sw reset or hw reset)
						
						pc_usb_msg_queue = GENERIC_SYSTEM_ERROR //send error out through the PC_USB for debugging
						
						if( error_origin != ROVERCOMM_COMM)//Make sure don't send it back to itself to avoid an infinite loop
						{
							comm_msg_queue = GENERIC_SYSTEM_ERROR;//send error to comm which will send a copy to cmnc as well
							
							comm_cmnc_destination_selection = ROVERCOMM_COMM;
							
						}//end if								
						if( error_origin != ROVERCOMM_NAVI)//Make sure don't send it back to itself to avoid an infinite loop
						{
							navi_msg_queue = CMD_TAG_GENERIC_SYSTEM_ERROR_STATUS;//also send a copy to NAVI so every Arduino will know of the error
						}//end if	
						if( error_origin != ROVERCOMM_AUXI)//Make sure don't send it back to itself to avoid an infinite loop
						{
							auxi_msg_queue = CMD_TAG_GENERIC_SYSTEM_ERROR_STATUS;//also send a copy to AUXI so every Arduino will know of the error
						}//end if	
						
					end if
			
					
					
					
					Note: Any other messages created for COMM/CMNC has priority over error messages. Error messages are just for status, but any other messages may be used for debugging.											

				
					//Run highest priority functions here. //this will override any lower priority messages
			


					//increment the loop count while MAIN is still in SYSTEM_ERROR. This should take highest priority.
					timeout_counter++;					
					//if MAIN has been stuck in SYSTEM_ERROR for a long time, request for COMM to do a hw reset
					if timeout_counter >= MAIN_SYSTEM_ERROR_TIMEOUT_VALUE						
						comm_msg_queue = ALL_HW_RESET_REQUEST
						comm_cmnc_destination_selection = ROVERCOMM_COMM;
						//do not clear the counter. allow it to keep sending ALL_HW_RESET_REQUEST to COMM until a HW reset is done by COMM to MAIN
					end if
					
	
					Unless overridden,				
						Mode: SYSTEM_ERROR	
					Unless overridden,
						Set next state to CONTROL_OUTPUTS
					go to RUN_HOUSEKEEPING_TASKS					
			CONTROL_OUTPUTS			
				POWER_ON_AND_HW_RESET
					do nothing
				INITIALIZATION
					do nothing		
				SYNCHRONIZATION
					do nothing								
				NORMAL_OPERATIONS	
					Control MotorPowerControl
						if enable_mtr_pwr
							enable motor power mosfet
						else
							disable motor power mosfet
						end if
					Mode: NORMAL_OPERATIONS									
					set next state to CREATE_DATA					
					go to RUN_HOUSEKEEPING_TASKS		
				HW_RESETTING
					HW reset COMM
					Mode: SYNCHRONIZATION *begin* //go back to SYNCHRONIZATION

					//Queue up system ready messages
					pc_usb_msg_queue = CMD_TAG_SYSTEM_READY_STATUS;
					comm_msg_queue = CMD_TAG_SYSTEM_READY_STATUS;
					navi_msg_queue = CMD_TAG_SYSTEM_READY_STATUS;				
					auxi_msg_queue = CMD_TAG_SYSTEM_READY_STATUS;

					comm_cmnc_destination_selection = ROVERCOMM_COMM;//default
					
					once HW Reset it done
					//initialize/reset shared counter before use
					timeout_counter = 0;
					set next state to CREATE_DATA
					go to RUN_HOUSEKEEPING_TASKS					
				SYSTEM_SLEEPING
					Control MotorPowerControl				
					if enable_mtr_pwr == false	
						shut off motor power			
					end if		
					Note: Do not go to sleep yet, have to send out COMM_SLEEP_REQUEST to COMM.
					set next state to CREATE_DATA
					go to RUN_HOUSEKEEPING_TASKS						
				SYSTEM_WAKING
					
					Wake up NAVI (toggles the wakeup pin to low, then back to high)
					Wake up AUXI (toggles the wakeup pin to low, then back to high)
					
					Control MotorPowerControl
					if enable_mtr_pwr
						enable motor power mosfet
					else
						disable motor power mosfet
					end if			
					
					Set mode to SYNCHRONIZATION *begin*		
					
					//Queue up system ready messages
					pc_usb_msg_queue = CMD_TAG_SYSTEM_READY_STATUS;
					comm_msg_queue = CMD_TAG_SYSTEM_READY_STATUS;
					navi_msg_queue = CMD_TAG_SYSTEM_READY_STATUS;				
					auxi_msg_queue = CMD_TAG_SYSTEM_READY_STATUS;
			
					comm_cmnc_destination_selection = ROVERCOMM_COMM;//default
					
					//initialize/reset shared counter before use
					timeout_counter = 0;							
					
					set next state to CREATE_DATA
					go to RUN_HOUSEKEEPING_TASKS				
				SW_RESETTING
					Control MotorPowerControl					
					since enable_mtr_pwr == false	
						shut off motor power			
					Mode: SW_RESETTING						
					set next state to CREATE_DATA					
					go to RUN_HOUSEKEEPING_TASKS						
				SYSTEM_ERROR
					Control MotorPowerControl				
					since enable_mtr_pwr == false	
						shut off motor power			
					Mode: SYSTEM_ERROR					
					set next state to CREATE_DATA					
					go to RUN_HOUSEKEEPING_TASKS						
			CREATE_DATA
				POWER_ON_AND_HW_RESET
					do nothing
				INITIALIZATION
					do nothing		
				SYNCHRONIZATION
					//PC_USB
					if pc_usb_msg_queue != CMD_TAG_NO_MSG
						create any msg(s) for PC_USB as needed based on pc_usb_msg_queue		
						
						//skip auto data						
						
					endif
					//COMM
					if (since) comm_msg_queue = SYSTEM_READY_STATUS
					
						//And since comm_cmnc_destination_selection = ROVERCOMM_COMM
						if(comm_cmnc_destination_selection == ROVERCOMM_COMM)
							create system ready msg for COMM
														
						else if(comm_cmnc_destination_selection == ROVERCOMM_CMNC)//This code should not execute when in SYNCHRONIZATION. Just have it there for consistency.
							create system ready msg for CMNC		
								
						else
							Send error message. As it's an unknown destination.
						end else
																		
						
						//skip auto data						
						
					endif						
					//NAVI
					if navi_msg_queue = SYSTEM_READY_STATUS
						create system ready msg for NAVI
						
						//skip auto data						
						
					endif
					//AUXI
					if auxi_msg_queue = SYSTEM_READY_STATUS
						create system ready msg for AUXI
						
						//skip auto data
						
					endif
					
					
					Clear Motor Power Status (so it can be re-read again next loop)
					
					
					Mode: SYNCHRONIZATION
					set next state to TX_COMMUNICATIONS						
					go to RUN_HOUSEKEEPING_TASKS				
				NORMAL_OPERATIONS						
					//PC_USB
					if pc_usb_msg_queue != CMD_TAG_NO_MSG
						create any msg(s) for PC_USB as needed based on pc_usb_msg_queue		
					end if
					//COMM
					if comm_msg_queue != CMD_TAG_NO_MSG
					//create any msg(s) for COMM or CMNC (since they all go through COMM) as needed based on comm_msg_queue	
						if(comm_cmnc_destination_selection == ROVERCOMM_COMM)
								create system ready msg for COMM
																
						else if(comm_cmnc_destination_selection == ROVERCOMM_CMNC)
								create system ready msg for CMNC		
								
						else
							Send error message. As it's an unknown destination.
						end else

						
					
					end if
					//Since this is a shared data channel, create message corresponding to the next auto data for COMM, then for CMNC
					else if( auto_MAIN_to_COMM_data_cnt < sizeof(auto_MAIN_to_COMM_data_array) )
						//if there is auto data for COMM and it has not been all sent yet
						//Note: Since the counter is a byte, it's lowest value is 0. And the array size can't be smaller than zero. So this can only be true if the array has data, i.e. it's size is greater than 0 and the counter is less than the size of the array. If the array is empty, the size would be 0 and the counter's lowest value would be 0, so it would be equal and not less than, so the if statement would be still false.
					
						comm_msg_queue = auto_MAIN_to_COMM_data_array[auto_MAIN_to_COMM_data_cnt]
						
						//set the next auto data for COMM for the next loop
						auto_MAIN_to_COMM_data_cnt++
						
						comm_cmnc_destination_selection = ROVERCOMM_COMM//set destination to COMM
						
						
					end else if
					else if( auto_MAIN_to_CMNC_data_cnt < sizeof(auto_MAIN_to_CMNC_data_array))
						//if there is auto data for CMNC and it has not been all sent yet
						//Note: Since the counter is a byte, it's lowest value is 0. And the array size can't be smaller than zero. So this can only be true if the array has data, i.e. it's size is greater than 0 and the counter is less than the size of the array. If the array is empty, the size would be 0 and the counter's lowest value would be 0, so it would be equal and not less than, so the if statement would be still false.
					
						//since there is no custom data, then send the next auto data.
						//create message corresponding to the next auto data for COMM.
						
						comm_msg_queue = auto_MAIN_to_CMNC_data_array[auto_MAIN_to_CMNC_data_cnt]
						
						//set the next auto data for CMNC for the next loop
						auto_MAIN_to_CMNC_data_cnt++
						
						comm_cmnc_destination_selection = ROVERCOMM_CMNC//set destination to CMNC
						
						
					end else if
					//else do nothing since there was no message and no auto data to send
						
	
						
					end if					
					//NAVI
					if navi_msg_queue != CMD_TAG_NO_MSG
						create any msg(s) for NAVI as needed based on navi_msg_queue					
					else if( auto_MAIN_to_NAVI_data_cnt < sizeof(auto_MAIN_to_NAVI_data_array))
						//if there is auto data for NAVI and it has not been all sent yet
						//Note: Since the counter is a byte, it's lowest value is 0. And the array size can't be smaller than zero. So this can only be true if the array has data, i.e. it's size is greater than 0 and the counter is less than the size of the array. If the array is empty, the size would be 0 and the counter's lowest value would be 0, so it would be equal and not less than, so the if statement would be still false.
					
													
						//since there is no custom data, then send the next auto data.
						//create message corresponding to the next auto data for NAVI.
						
						navi_msg_queue = auto_MAIN_to_NAVI_data_array[auto_MAIN_to_NAVI_data_cnt]
						//set the next auto data for NAVI for the next loop
						auto_MAIN_to_NAVI_data_cnt++
		
					end if
					//AUXI
					if auxi_msg_queue != CMD_TAG_NO_MSG
						create any msg(s) for AUXI as needed based on auxi_msg_queue					
					else if( auto_MAIN_to_AUXI_data_cnt < sizeof(auto_MAIN_to_AUXI_data_cnt))
						//if there is auto data for AUXI and it has not been all sent yet
						//Note: Since the counter is a byte, it's lowest value is 0. And the array size can't be smaller than zero. So this can only be true if the array has data, i.e. it's size is greater than 0 and the counter is less than the size of the array. If the array is empty, the size would be 0 and the counter's lowest value would be 0, so it would be equal and not less than, so the if statement would be still false.
					
													
						//since there is no custom data, then send the next auto data.
						//create message corresponding to the next auto data for AUXI.
						
						auxi_msg_queue = auto_MAIN_to_AUXI_data_array[auto_MAIN_to_AUXI_data_cnt]
						//set the next auto data for AUXI for the next loop
						auto_MAIN_to_AUXI_data_cnt++

					end if
			
					//Once all the counters are equal to or greater than the size of the arrays (or even if the array is empty with size 0), reset all the counters)
					if (
						auto_MAIN_to_COMM_data_cnt >= sizeof(auto_MAIN_to_COMM_data_array) &&
						auto_MAIN_to_CMNC_data_cnt >= sizeof(auto_MAIN_to_CMNC_data_array) &&
						auto_MAIN_to_NAVI_data_cnt >= sizeof(auto_MAIN_to_NAVI_data_array) &&
						auto_MAIN_to_AUXI_data_cnt >= sizeof(auto_MAIN_to_AUXI_data_array)
						)
							auto_MAIN_to_COMM_data_cnt = 0;
							auto_MAIN_to_CMNC_data_cnt = 0;
							auto_MAIN_to_NAVI_data_cnt = 0;
							auto_MAIN_to_AUXI_data_cnt = 0;
					endif
					
					
					Clear Motor Power Status (so it can be re-read again next loop)
					
					Mode: NORMAL_OPERATIONS
					set next state to TX_COMMUNICATIONS						
					go to RUN_HOUSEKEEPING_TASKS					
				HW_RESETTING
					do nothing
				SYSTEM_SLEEPING
					//PC_USB
					if pc_usb_msg_queue != CMD_TAG_NO_MSG
						create any msg(s) for PC_USB as needed based on pc_usb_msg_queue		
						
						//skip auto data
						
					endif
					//COMM
					if (since) comm_msg_queue = COMM_SLEEP_REQUEST	
					
						//And since comm_cmnc_destination_selection = ROVERCOMM_COMM
						if(comm_cmnc_destination_selection == ROVERCOMM_COMM)							
							Create COMM sleep request after acknowledgements are received from both AUXI and NAVI (it should be cleared out to CMD_TAG_NO_MSG after the request has been sent, in TX_COMMUNICATIONS, so it doesn't get stuck in a loop)							
														
						else if(comm_cmnc_destination_selection == ROVERCOMM_CMNC)//This code should not execute when in SYSTEM_SLEEPING. Just have it there for consistency.
							create system ready msg for CMNC		
							
						else
							Send error message. As it's an unknown destination.
						end else		
						
						
					
						//skip auto data												
					endif
					//NAVI
					Since navi_msg_queue = NAVI_SLEEP_REQUEST (it should be cleared out to CMD_TAG_NO_MSG after the request has been sent, in TX_COMMUNICATIONS, so it doesn't get stuck in a loop)
						Create NAVI sleep request msg
						
						//skip auto data
						
					//AUXI
					Since auxi_msg_queue = AUXI_SLEEP_REQUEST (it should be cleared out to CMD_TAG_NO_MSG after the request has been sent, in TX_COMMUNICATIONS, so it doesn't get stuck in a loop)
						Create AUXI sleep request msg					
						
						//skip auto data
					
					Clear Motor Power Status (so it can be re-read again next loop)
										
					set next state to TX_COMMUNICATIONS
					go to RUN_HOUSEKEEPING_TASKS			
				SYSTEM_WAKING
					do nothing					
				SW_RESETTING
					//PC_USB
					if pc_usb_msg_queue != CMD_TAG_NO_MSG
						create any msg(s) for PC_USB as needed based on pc_usb_msg_queue		
						
						//skip auto data
						
						
					endif
					
					//COMM
					if (since) comm_msg_queue = COMM_SW_RESET_REQUEST	
					
						//And since comm_cmnc_destination_selection = ROVERCOMM_COMM
						if(comm_cmnc_destination_selection == ROVERCOMM_COMM)
							
							Create COMM SW reset request after acknowledgements are received from both AUXI and NAVI		
							
							
						else if(comm_cmnc_destination_selection == ROVERCOMM_CMNC)//This code should not execute when in SW_RESETTING. Just have it there for consistency.
							create system ready msg for CMNC		
							
						else
							Send error message. As it's an unknown destination.
						end else	
						
						
					
						//skip auto data												
					endif						

					//NAVI
					if navi_msg_queue = NAVI_SW_RESET_REQUEST (it should be cleared out to CMD_TAG_NO_MSG after the request has been sent, so it doesn't get stuck in a loop, i.e. keeps resetting itself))
						Create NAVI sw reset request msg
						
						//skip auto data
						
					//AUXI
					if auxi_msg_queue = AUXI_SW_RESET_REQUEST (it should be cleared out to CMD_TAG_NO_MSG after the request has been sent, so it doesn't get stuck in a loop, i.e. keeps resetting itself))
						Create AUXI sw reset request msg						
				
						//skip auto data

					Clear Motor Power Status (so it can be re-read again next loop)
					
					set next state to TX_COMMUNICATIONS
					go to RUN_HOUSEKEEPING_TASKS
				SYSTEM_ERROR		
					//PC_USB
					if pc_usb_msg_queue != CMD_TAG_NO_MSG
						create any msg(s) for PC_USB as needed based on pc_usb_msg_queue		
						
						For SYNC_ERROR_STATUS, SLEEP_ERROR_STATUS,
						SW_RESET_ERROR_STATUS, GENERIC_SYSTEM_ERROR_STATUS,
						CMD_TAG_GENERIC_HEALTH_STATUS_ERROR, INVALID_STATE_ERROR_STATUS, in createDataFromQueueFor, create the message using error_origin as the message origin
							
						//skip auto data
						
					endif
					//COMM

					if comm_msg_queue != CMD_TAG_NO_MSG
						
						For SYNC_ERROR_STATUS, SLEEP_ERROR_STATUS,
						SW_RESET_ERROR_STATUS, GENERIC_SYSTEM_ERROR_STATUS,
						CMD_TAG_GENERIC_HEALTH_STATUS_ERROR, in createDataFromQueueFor, create the message using error_origin as the message origin
												
						For CMD_TAG_INVALID_STATE_OR_MODE_ERROR_STATUS, in createDataFromQueueFor, create the message using error_origin as the message origin and cmnc as the destination
					
					
						if(comm_cmnc_destination_selection == ROVERCOMM_COMM)
							create any msg(s) for COMM as needed based on comm_msg_queue						
							//should be general or specific error messages, unless ALL_HW_RESET_REQUEST is in the queue, then it has priority over system error messages.		
							
						else if(comm_cmnc_destination_selection == ROVERCOMM_CMNC)
							create any msg(s) for CMNC (through COMM) as needed based on comm_msg_queue						
							//should be general or specific error messages, unless ALL_HW_RESET_REQUEST is in the queue, then it has priority over system error messages.
							
						else
							Send error message. As it's an unknown destination.
						end else
						
						
						
						//skip auto data						
						
					endif			
					

					//NAVI
					if navi_msg_queue != CMD_TAG_NO_MSG
						create any msg(s) for NAVI as needed based on navi_msg_queue
						//should be general or specific error messages if no other has priority, skip auto data
						
						//skip auto data
						
						For GENERIC_SYSTEM_ERROR_STATUS, CMD_TAG_GENERIC_HEALTH_STATUS_ERROR in createDataFromQueueFor, create the message using error_origin as the message origin
						
					end if
					//AUXI
					if auxi_msg_queue != CMD_TAG_NO_MSG
						create any msg(s) for AUXI as needed based on auxi_msg_queue					
						//should be general or specific error messages if no other has priority, skip auto data
						
						//skip auto data
						
						For GENERIC_SYSTEM_ERROR_STATUS, CMD_TAG_GENERIC_HEALTH_STATUS_ERROR in createDataFromQueueFor, create the message using error_origin as the message origin
						
					end if

						
						
					end if				
					
					Clear Motor Power Status (so it can be re-read again next loop)
										
					Mode: SYSTEM_ERROR
					set next state to TX_COMMUNICATIONS					
					go to RUN_HOUSEKEEPING_TASKS				
			TX_COMMUNICATIONS		
				POWER_ON_AND_HW_RESET
					do nothing
				INITIALIZATION
					do nothing
				SYNCHRONIZATION		
					Note: No redirection during SYNCHRONIZATION.
					if pc_usb_msg_queue != CMD_TAG_NO_MSG
						Sends internally generated msg(s) to PC_USB
					end if		
					if comm_msg_queue != CMD_TAG_NO_MSG
						Sends internally generated msg(s) to COMM
					end if						
					if navi_msg_queue != CMD_TAG_NO_MSG
						Sends internally generated msg(s) to NAVI
					end if	
					if auxi_msg_queue != CMD_TAG_NO_MSG
						Sends internally generated msg(s) to AUXI
					end if						
									
					clear message queues and redirect flags
						pc_usb_msg_queue = CMD_TAG_NO_MSG					
						navi_msg_queue = CMD_TAG_NO_MSG					
						auxi_msg_queue = CMD_TAG_NO_MSG
						comm_msg_queue = CMD_TAG_NO_MSG
						comm_cmnc_destination_selection = ROVERCOMM_COMM;//default
						redirectToPCUSB = false
						redirectToNAVI = false
						redirectToAUXI = false
						redirectToCOMM = false						
					first_transmission = true //reset the flag						
					Mode: SYNCHRONIZATION
					set next state to RX_COMMUNICATIONS											
					go to RUN_HOUSEKEEPING_TASKS				
				NORMAL_OPERATIONS		
					if first_transmission == true		
						
						//send the first set of messages
						if pc_usb_msg_queue != CMD_TAG_NO_MSG
							Sends internally generated msg(s) to PC_USB
						end if
						if comm_msg_queue != CMD_TAG_NO_MSG
							Sends internally generated msg(s) to COMM
						end if						
						if navi_msg_queue != CMD_TAG_NO_MSG
							Sends internally generated msg(s) to NAVI
						end if	
						if auxi_msg_queue != CMD_TAG_NO_MSG
							Sends internally generated msg(s) to AUXI
						end if						

						//check to see if there are any second messages to send
						if redirectToCOMM == true || redirectToNAVI == true || redirectToAUXI == true || redirectToPCUSB
							first_transmission = false //clear the flag, so on the next iteration it won't process as the first transmission
							//reset the counter before use
							transmission_delay_cnt = 0
							Mode: NORMAL_OPERATIONS
							set next state to TX_COMMUNICATIONS //return to this state after running house keeping tasks (to allow for delays before another transmission)					
							go to RUN_HOUSEKEEPING_TASKS	
						else//if there is no second transmission, move on
							clear message queues and redirect flags
								pc_usb_msg_queue = CMD_TAG_NO_MSG
								navi_msg_queue = CMD_TAG_NO_MSG					
								auxi_msg_queue = CMD_TAG_NO_MSG
								comm_msg_queue = CMD_TAG_NO_MSG
								comm_cmnc_destination_selection = ROVERCOMM_COMM;//default
								redirectToPCUSB = false
								redirectToNAVI = false
								redirectToAUXI = false
								redirectToCOMM = false	
							first_transmission = true //reset the flag								
							Mode: NORMAL_OPERATIONS
							set next state to RX_COMMUNICATIONS
							go to RUN_HOUSEKEEPING_TASKS							
						end if						
					else			
						if transmission_delay_cnt >= CONCURRENT_TRANSMISSION_DELAY //once the desired delay has been reached, continue with the code							
							//Send the second set of messages
							if redirectToPCUSB == true
								Redirect external msg(s) to PC_USB
							end if				
							if redirectToCOMM == true
								Redirect external msg(s) to COMM
							end if				
							if redirectToNAVI == true
								Redirect external msg(s) to NAVI
							end if				
							if redirectToAUXI == true
								Redirect external msg(s) to AUXI
							end if
							clear message queues and redirect flags
								pc_usb_msg_queue = CMD_TAG_NO_MSG
								navi_msg_queue = CMD_TAG_NO_MSG					
								auxi_msg_queue = CMD_TAG_NO_MSG
								comm_msg_queue = CMD_TAG_NO_MSG
								comm_cmnc_destination_selection = ROVERCOMM_COMM;//default
								redirectToPCUSB = false
								redirectToNAVI = false
								redirectToAUXI = false
								redirectToCOMM = false		
							first_transmission = true //reset the flag
							Mode: NORMAL_OPERATIONS
							set next state to RX_COMMUNICATIONS					
							go to RUN_HOUSEKEEPING_TASKS	
						else
							transmission_delay_cnt++//increment the transmission delay counter
							Mode: NORMAL_OPERATIONS
							set next state to TX_COMMUNICATIONS //return to this state after running house keeping tasks (to allow for delays before another transmission)					
							go to RUN_HOUSEKEEPING_TASKS	
						end if
					end if			
				HW_RESETTING
					do nothing				
				SYSTEM_SLEEPING
					Note: No redirection during SYSTEM_SLEEPING.
					
					if pc_usb_msg_queue != CMD_TAG_NO_MSG
						Sends internally generated msg(s) to PC_USB
					end if	
					if comm_msg_queue != CMD_TAG_NO_MSG
						Sends internally generated msg(s) to COMM						
					end if					
					if navi_msg_queue != CMD_TAG_NO_MSG
						Sends internally generated msg(s) to NAVI
					end if	
					if auxi_msg_queue != CMD_TAG_NO_MSG
						Sends internally generated msg(s) to AUXI
					end if						
				
					clear message queues and redirect flags
						pc_usb_msg_queue = CMD_TAG_NO_MSG
						navi_msg_queue = CMD_TAG_NO_MSG					
						auxi_msg_queue = CMD_TAG_NO_MSG
						comm_msg_queue = CMD_TAG_NO_MSG
						comm_cmnc_destination_selection = ROVERCOMM_COMM;//default
						redirectToPCUSB = false
						redirectToNAVI = false
						redirectToAUXI = false
						redirectToCOMM = false					
					first_transmission = true //reset the flag
					if run_task_on_main_now == true
						run_task_on_main_now = false //clear the flag
						//MAIN Sleeps itself once the request from MAIN to COMM for COMM to sleep itself has been sent
						//TROUBLESHOOT TIP: If this COMM sleep request is missed by COMM, then COMM will need to start the sleep process again since MAIN already slept. If this happens COMM will go into error mode after timing out and wait for a HW reset (as MAIN and possibly NAVI and AUXI are asleep and won't respond to a SW reset request)
							Improvement Tip: I could add a wakeup step for SW resets just in case, any of the Arduinos are asleep, before going the SW reset, but this will get complicated/messy. Good enough for now.
						
						//SETUP FOR WAKEUP
						Mode: SYSTEM_WAKING *begin* //setup this mode ahead of time before going to sleep
						set next state to CONTROL_OUTPUTS //Go to CONTROL_OUTPUTS in order to wake NAVI and AUXI from sleep and to restore the motor prev state
					
						//Restore previous motor state
						enable_mtr_pwr = motor_power_prev_state

						//clear the flag for future reuse
						motor_power_prev_state = false					

						Run other pre-sleep tasks. (i.e. end software serial, as needed)
						//END OF SETUP FOR WAKEUP
						
						
						//GOING TO SLEEP
						Put MAIN to sleep
							Don't switch states yet. Go to sleep in the current TX_COMMUNICATIONS state.

						//WAKING UP
						COMM will wake up MAIN from the sleep.

						Run wake up tasks. (i.e. begin SW serial as needed, etc.)
						While in the SYSTEM_WAKING mode, after going to RUN_HOUSEKEEPING_TASKS, it will go to the next state, which is set to CONTROL_OUTPUTS
					else
						Mode: SYSTEM_SLEEPING
						set next state to RX_COMMUNICATIONS					
					end if
					go to RUN_HOUSEKEEPING_TASKS					
				SYSTEM_WAKING
					do nothing
				SW_RESETTING
					Note: No redirection during sw resets					
					if pc_usb_msg_queue != CMD_TAG_NO_MSG
						Sends internally generated msg(s) to PC_USB
					end if	
					if comm_msg_queue != CMD_TAG_NO_MSG
						Sends internally generated msg(s) to COMM						
					end if						
					if navi_msg_queue != CMD_TAG_NO_MSG
						Sends internally generated msg(s) to NAVI
					end if	
					if auxi_msg_queue != CMD_TAG_NO_MSG
						Sends internally generated msg(s) to AUXI
					end if						
			
					clear message queues and redirect flags
						navi_msg_queue = CMD_TAG_NO_MSG					
						auxi_msg_queue = CMD_TAG_NO_MSG
						comm_msg_queue = CMD_TAG_NO_MSG
						comm_cmnc_destination_selection = ROVERCOMM_COMM;//default
						pc_usb_msg_queue = CMD_TAG_NO_MSG
						redirectToPCUSB = false
						redirectToNAVI = false
						redirectToAUXI = false
						redirectToCOMM = false					
					first_transmission = true //reset the flag
					if run_task_on_main_now == true
						run_task_on_main_now = false //clear the flag
						//MAIN SW resets itself once the request from MAIN to COMM for COMM to sw reset itself has been sent
						//TROUBLESHOOT TIP: If this COMM sw reset request is missed by COMM, then COMM will need to start the All SW Reset Request process again since MAIN already SW resetted and should be waiting in the SYNCHRONIZATION mode
						Mode: INITIALIZATION *begin*
						Next State: RUN_HOUSEKEEPING_TASKS			
					else
						Mode: SW_RESETTING
						set next state to RX_COMMUNICATIONS					
					go to RUN_HOUSEKEEPING_TASKS					
				SYSTEM_ERROR				
					if first_transmission == true		
												
						//send the first set of messages
						if pc_usb_msg_queue != CMD_TAG_NO_MSG
							Sends internally generated msg(s) to PC_USB
						end if	
						if comm_msg_queue != CMD_TAG_NO_MSG
							Sends internally generated msg(s) to COMM
						end if							
						if navi_msg_queue != CMD_TAG_NO_MSG
							Sends internally generated msg(s) to NAVI
						end if	
						if auxi_msg_queue != CMD_TAG_NO_MSG
							Sends internally generated msg(s) to AUXI
						end if						
					
						//check to see if there are any second messages to send
						if redirectToCOMM == true || redirectToNAVI == true || redirectToAUXI == true || redirectToPCUSB
							first_transmission = false //clear the flag, so on the next iteration it won't process as the first transmission
							//reset the counter before use
							transmission_delay_cnt = 0
							Mode: SYSTEM_ERROR
							set next state to TX_COMMUNICATIONS //return to this state after running house keeping tasks (to allow for delays before another transmission)					
							go to RUN_HOUSEKEEPING_TASKS	
						else//if there is no second transmission, move on
							clear message queues and redirect flags
								pc_usb_msg_queue = CMD_TAG_NO_MSG
								navi_msg_queue = CMD_TAG_NO_MSG					
								auxi_msg_queue = CMD_TAG_NO_MSG
								comm_msg_queue = CMD_TAG_NO_MSG
								comm_cmnc_destination_selection = ROVERCOMM_COMM;//default
								redirectToPCUSB = false
								redirectToNAVI = false
								redirectToAUXI = false
								redirectToCOMM = false			
							first_transmission = true //reset the flag								
							Mode: SYSTEM_ERROR
							set next state to RX_COMMUNICATIONS
							go to RUN_HOUSEKEEPING_TASKS							
						end if						
					else			
						if transmission_delay_cnt >= CONCURRENT_TRANSMISSION_DELAY //once the desired delay has been reached, continue with the code							
							//Send the second set of messages
							if redirectToPCUSB == true
								Redirect external msg(s) to PC_USB
							end if								
							if redirectToCOMM == true
								Redirect external msg(s) to COMM
							end if				
							if redirectToNAVI == true
								Redirect external msg(s) to NAVI
							end if				
							if redirectToAUXI == true
								Redirect external msg(s) to AUXI
							end if
							clear message queues and redirect flags
								pc_usb_msg_queue = CMD_TAG_NO_MSG
								navi_msg_queue = CMD_TAG_NO_MSG					
								auxi_msg_queue = CMD_TAG_NO_MSG
								comm_msg_queue = CMD_TAG_NO_MSG
								comm_cmnc_destination_selection = ROVERCOMM_COMM;//default
								redirectToPCUSB = false
								redirectToNAVI = false
								redirectToAUXI = false
								redirectToCOMM = false		
							first_transmission = true //reset the flag
							Mode: SYSTEM_ERROR
							set next state to RX_COMMUNICATIONS
							go to RUN_HOUSEKEEPING_TASKS	
						else
							transmission_delay_cnt++//increment the transmission delay counter
							Mode: SYSTEM_ERROR
							set next state to TX_COMMUNICATIONS //return to this state after running house keeping tasks (to allow for delays before another transmission)					
							go to RUN_HOUSEKEEPING_TASKS	
						end if
					end if			
			DEFAULT:
				Set mode to SYSTEM_ERROR *begin*
				set enable_mtr_pwr = false //shut down motor when in error for safety
				comm_msg_queue = GENERIC_SYSTEM_ERROR//send COMM a generic system error for now since COMM doesn't handle other errors yet (besides generic health errors). And though you can try to send it to CMNC, sometimes redirection may be off in certain modes. So it's better for COMM to receive a generic error and do what it has to do (i.e. put the LED indicator to error pattern and send a generic system error to CMNC)
				pc_usb_msg_queue = CMD_TAG_INVALID_STATE_OR_MODE_ERROR_STATUS
				navi_msg_queue = GENERIC_SYSTEM_ERROR_STATUS
				auxi_msg_queue = GENERIC_SYSTEM_ERROR_STATUS
				comm_cmnc_destination_selection = ROVERCOMM_COMM;
				
				Set error_origin = ROVERCOMM_MAIN				
				set invalid_state_or_mode_error = true
						(Note: the invalid_state_or_mode_error flag can only be cleared with a sw reset or hw reset)
				//initialize/reset shared counter before use
				timeout_counter = 0;
				Set next state to CONTROL_OUTPUTS								
				go to RUN_HOUSEKEEPING_TASKS								
							
							
		
			



			
			
			
State Matrix Design = States vs. Modes			
==================
States
==================
Note: These states don't always have to go in order.
	RUN_HOUSEKEEPING_TASKS
		runs in parallel with every loop
	RX_COMMUNICATIONS
		rxData()
	DATA_VALIDATION
		data parsing and validation
		parseAndValidateData()
	DATA_FILTER
		dataDirector()
	READ_INPUTS
	PROCESS_DATA
		commandDirector()
	CONTROL_OUTPUTS			
	CREATE_DATA
	TX_COMMUNICATIONS		
	
==================
Modes
==================
Note: These states don't always have to go in order.
Note: *begin* means this is one of the starting points for this mode

POWER_ON_AND_HW_RESET
INITIALIZATION
SYNCHRONIZATION					
NORMAL_OPERATIONS						
HW_RESETTING
SYSTEM_SLEEPING
SYSTEM_WAKING
SW_RESETTING
SYSTEM_ERROR
DEFAULT
		
==================
Command Options (i.e. used in the PROCESS_DATA state. Typically from the NORMAL_OPERATIONS mode, but not always)
==================	
Note: Since the message queues (i.e. cmnc_msg_queue, etc.) are shared between external arduinos and this internal arduino, there could be data overwrites and lost. If this is an issue, you may have to redesign.
	Also since it only reads data once, you might miss data as well.
	You can't do a queue emptied status since the way the roverComm object is written, it takes in only one string and saves that for processing.
	Also the way it's currently designed, it will read up the the ROVER_COMM_SENTENCE_LENGTH, so if you send commands back to back, you may get two messages merged together and only one processed.
	You would have to have a delay and/or send end lines between the two messages.
	Messages can come from multiple arduinos to the same queue for a particular arduino.
	Best to just keep resending messages until you get an acknowledgement for anything that is important.
	Will have to just take the risk and add delay between possible multiple message sends to the same arduinos
	And if more than one wants to write to the same queue (and it's not a redirect) will need to prioritize and drop the other. At the end of the day, only one command can be run at a time on the other end (the receiving Arduino) anyways. If anything, you can have it wait for a status and keep resending the message if it's that important.
	Categorize all commands/data from all sources.
	Allow for all non-conflicting commands to run.
	Sort based on priority.
	Then only run the highest priority for this arduino.
	Note: If these messages don't work, the other (but less desirable option) is have all commands/requests/data sent to MAIN and it will arbitrate everything.
			
	
Note: No synchronization timeout will be used for MAIN. COMM will timeout and let the external CMNC know it needs action. Nothing to do internally with MAIN.
Note: With external commands, you only want to do all hw or all sw request (and not individual hw/sw requests). Else the system won't be in sync anymore. So hw/sw requests must be synced and have controlled points of entry.
	But internally, it may call individual commands as required.
Note: With external commands, you only want to do all sleep requests (and not individual sleep requests). Else the system won't be in sync anymore. So sleep requests must be synced and have controlled points of entry.
	But internally, it may call individual commands as required.

	
Non-Conflicting Functions (i.e. it doesn't override the message queues or change states or modes)


		

Conflicting Functions Ordered By Priority	
	Note: Don't forget to look at Non-Conflicting Functions as well.
	Most of the time (but not always), these commands will be ran from NORMAL_OPERATIONS mode under the PROCESS_DATA state. The next state is CONTROL_OUTPUTS, unless overwritten.

	
	COMM HW Reset Request
		Note: The current state is PROCESS_DATA and current mode is SYNCHRONIZATION since MAIN just got HW resetted and now COMM is waiting to be HW resetted.
		Note: There MAIN doesn't really have it's own HW Reset Request. That's done by the COMM, which will HW reset the MAIN, NAVI, and AUXI.
		Mode: HW_RESETTING *begin*
	All SW Reset Request
		//Create first message here and regenerate later on as needed
		navi_msg_queue = NAVI_SW_RESET_REQUEST
		auxi_msg_queue = AUXI_SW_RESET_REQUEST
		
		//initialize/reset shared flags before use
		navi_acknowledgement = false
		auxi_acknowledgement = false		
		run_task_on_main_now = false
		
		set enable_mtr_pwr = false //shut down motor when sw resetting for safety						
		Mode: SW_RESETTING *begin*	
		//Note: The actual SW reset will happen after TX_COMMUNICATIONS where it goes into INITIALIZATION.
		
	SW Reset Acknowledgement (usually from NAVI or AUXI)
		//Check to see where the command was from
		If command was from NAVI
			navi_acknowledgement = true
		else if command was from AUXI
			auxi_acknowledgement = true
		end if		
		//once MAIN gets an ack for sw reset from both NAVI and AUXI
		if navi_acknowledgement == true && auxi_acknowledgement = true
			run_task_on_main_now = true			
		end if
		Mode: SW_RESETTING
	
	Received Generic Health Error	

		//disabling of the motor is implied by the generic health status error
		
		//Create first message here and regenerate later on as needed
		pc_usb_msg_queue = CMD_TAG_GENERIC_HEALTH_STATUS_ERROR //send error out through the PC_USB for debugging

		if( error_origin != ROVERCOMM_COMM)//Make sure don't send it back to itself to avoid an infinite loop
		{
			comm_msg_queue = CMD_TAG_GENERIC_HEALTH_STATUS_ERROR;//send error to comm which will process it, then send a copy to cmnc as well
		}					
		if( error_origin != ROVERCOMM_NAVI)//Make sure don't send it back to itself to avoid an infinite loop
		{
			navi_msg_queue = CMD_TAG_GENERIC_HEALTH_STATUS_ERROR;//also send a copy to NAVI so every Arduino will know of the error
		}//end if	
		if( error_origin != ROVERCOMM_AUXI)//Make sure don't send it back to itself to avoid an infinite loop
		{
			auxi_msg_queue = CMD_TAG_GENERIC_HEALTH_STATUS_ERROR;//also send a copy to AUXI so every Arduino will know of the error
		}//end if			
		
		
		set generic_health_error = true
			(Note: the generic_health_error flag can only be cleared with a sw reset or hw reset)			
	
		//Assign the error_origin to where the data was generated from
		If command was from CMNC
			Set error_origin = ROVERCOMM_CMNC
		else if command was from NAVI
			Set error_origin = ROVERCOMM_NAVI
		else if command was from AUXI
			Set error_origin = ROVERCOMM_AUXI
		else if command was from MAIN  (though this wouldn't happen as it would come from itself. just keep it there for consistency)
			Set error_origin = ROVERCOMM_MAIN				
		else if command was from COMM
			Set error_origin = ROVERCOMM_COMM							
		else if command was from PC_USB
			Set error_origin = ROVERCOMM_PC_USB							
		else
			Set error_origin = ROVERCOMM_NONE							
		end if				
			
		//initialize/reset shared counter before use
		timeout_counter = 0;		
		
		//turn off the motor when there is a health error for safety
		enable_mtr_pwr = false
		
		Set mode to SYSTEM_ERROR *begin*
	
	Received Generic System Error

		//For now just forward it to COMM (CMNC) and PC_USB (as well as other Arduinos), keeping the original destination. No need to go into SYSTEM_ERROR mode just yet. Only health errors need to go to SYSTEM_ERROR mode. Though NAVI and AUXI might go to SYSTEM_ERROR mode.
		
		//Create first message here and regenerate later on as needed
		
		
		generic_system_error = true
		
		pc_usb_msg_queue = GENERIC_SYSTEM_ERROR_STATUS
		
		if( error_origin != ROVERCOMM_COMM)//Make sure don't send it back to itself to avoid an infinite loop
		{
			comm_msg_queue = GENERIC_SYSTEM_ERROR_STATUS;//send error to comm which will process it, then send a copy to cmnc as well
		}						
		if( error_origin != ROVERCOMM_NAVI)//Make sure don't send it back to itself to avoid an infinite loop
		{
			navi_msg_queue = CMD_TAG_GENERIC_SYSTEM_ERROR_STATUS;//also send a copy to NAVI so every Arduino will know of the error
		}//end if	
		if( error_origin != ROVERCOMM_AUXI)//Make sure don't send it back to itself to avoid an infinite loop
		{
			auxi_msg_queue = CMD_TAG_GENERIC_SYSTEM_ERROR_STATUS;//also send a copy to AUXI so every Arduino will know of the error
		}//end if	
		
		(Note: the generic_system_error flag can only be cleared with a sw reset or hw reset)
		
		//Assign the error_origin to where the data was generated from
		If command was from CMNC
			Set error_origin = ROVERCOMM_CMNC
		else if command was from NAVI
			Set error_origin = ROVERCOMM_NAVI
		else if command was from AUXI
			Set error_origin = ROVERCOMM_AUXI
		else if command was from MAIN  (though this wouldn't happen as it would come from itself. just keep it there for consistency)
			Set error_origin = ROVERCOMM_MAIN			
		else if command was from COMM
			Set error_origin = ROVERCOMM_COMM							
		else if command was from PC_USB
			Set error_origin = ROVERCOMM_PC_USB							
		else
			Set error_origin = ROVERCOMM_NONE							
		end if		
		
		
		//All errors from AUXI, NAVI, COMM, MAIN, CMNC, PC_USB should be redirected to COMM, and COMM will redirect it to CMNC
		//Then CMNC will talk to COMM where it can then allow hw and sw resets, etc.
		Improvement Tip: MAIN can go into error mode if it gets an error message from AUXI, NAVI, COMM, MAIN, CMNC, PC_USB
	
	System Ready
		//Check to see where the command was from
		If command was from NAVI
			set navi_system_ready = true					
		else if command was from AUXI
			set auxi_system_ready = true		
		else if command was from COMM
			set comm_system_ready = true							
		end if
		//NOTE: Since this is a non-conflicting command, if resetting the timeout_counter here causes an issue, then take that out of the code
		if(navi_system_ready && auxi_system_ready && comm_system_ready) // if all systetms are ready, reset the timeout counter
			timeout_counter = 0;//reset timer
		end if
		
			

	All Sleep Request
	
		//Create first message here and regenerate later on as needed
		navi_msg_queue = NAVI_SLEEP_REQUEST
		auxi_msg_queue = AUXI_SLEEP_REQUEST

		//initialize/reset shared flags before use
		navi_acknowledgement = false
		auxi_acknowledgement = false		
		run_task_on_main_now = false
		
		//save the state of the motor power before shutting it off to go to sleep
		motor_power_prev_state = enable_mtr_pwr
		//set to shut down motor when sleeping for safety						
		set enable_mtr_pwr = false
		
		Mode: SYSTEM_SLEEPING *begin*

	
	Sleep Request Acknowledgement
		//Check to see where the command was from
		If command was from NAVI
			navi_acknowledgement = true
			Put NAVI to sleep
				//(actually NAVI puts itself to sleep after receiving a sleep request command and sending the Sleep Request Acknowledgement, but MAIN still needs to update the sleep status of NAVI before going to sleep itself, so it can wake up NAVI correctly)
		else if command was from AUXI
			auxi_acknowledgement = true
			Put AUXI to sleep
				//(actually AUXI puts itself to sleep after receiving a sleep request command and sending the Sleep Request Acknowledgement, but MAIN still needs to update the sleep status of AUXI before going to sleep itself, so it can wake up AUXI correctly)
		end if		
		//once MAIN gets an ack for system sleeping from both NAVI and AUXI
		if navi_acknowledgement == true && auxi_acknowledgement = true
			run_task_on_main_now = true			
		end if			
		Mode: SYSTEM_SLEEPING
	
		
		
	Set Motor Power Enable
		If Enable Motor Power
			turn on the motor
			enable_mtr_pwr = true
			navi_msg_queue = ENABLING_MTR_PWR
			auxi_msg_queue = ENABLING_MTR_PWR
			comm_msg_queue = ENABLING_MTR_PWR//to be redirected to CMNC
			comm_cmnc_destination_selection = ROVERCOMM_CMNC;
		Else//Disable Motor Power
			//if enable is not called, the disable motor power by default			
			enable_mtr_pwr = false
			navi_msg_queue = DISABLING_MTR_PWR
			auxi_msg_queue = DISABLING_MTR_PWR
			comm_msg_queue = DISABLING_MTR_PWR//to be redirected to CMNC		
			comm_cmnc_destination_selection = ROVERCOMM_CMNC;
		End If
			
	

	
	Get Motor Power Status
		//Check to see where the command was from
		If command was from NAVI
			navi_msg_queue = MTR_PWR_STATUS
		else if command was from AUXI
			auxi_msg_queue = MTR_PWR_STATUS
		else if command was from COMM
			comm_msg_queue = MTR_PWR_STATUS		
			comm_cmnc_destination_selection = ROVERCOMM_COMM
		else if command was from CMNC
			comm_msg_queue = MTR_PWR_STATUS
			comm_cmnc_destination_selection = ROVERCOMM_CMNC
		else if command was from PC_USB
			pc_usb_msg_queue = MTR_PWR_STATUS	
		end if	
	
	Get Mid Right Encoder Status
		//Check to see where the command was from
		If command was from NAVI
			navi_msg_queue = ENC_STATUS_MID_RIGHT
		else if command was from AUXI
			auxi_msg_queue = ENC_STATUS_MID_RIGHT
		else if command was from COMM
			comm_msg_queue = ENC_STATUS_MID_RIGHT
			comm_cmnc_destination_selection = ROVERCOMM_COMM
		else if command was from CMNC
			comm_msg_queue = ENC_STATUS_MID_RIGHT
			comm_cmnc_destination_selection = ROVERCOMM_CMNC
		else if command was from PC_USB
			pc_usb_msg_queue = ENC_STATUS_MID_RIGHT				
		end if	
	Get Mid Left Encoder Status
		//Check to see where the command was from
		If command was from NAVI
			navi_msg_queue = ENC_STATUS_MID_LEFT
		else if command was from AUXI
			auxi_msg_queue = ENC_STATUS_MID_LEFT
		else if command was from COMM
			comm_msg_queue = ENC_STATUS_MID_LEFT
			comm_cmnc_destination_selection = ROVERCOMM_COMM
		else if command was from CMNC
			comm_msg_queue = ENC_STATUS_MID_LEFT
			comm_cmnc_destination_selection = ROVERCOMM_CMNC
		else if command was from PC_USB
			pc_usb_msg_queue = ENC_STATUS_MID_LEFT					
		end if
	
	
IMPROVEMENT TIP: Maybe add system hold and system standby states later if have time.			
	